<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title></title>

    <!-- Theme (pick any from Prism site) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <!-- Prism core + Lisp language -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    table {
        border-collapse: collapse;      /* merge borders so you don't get double lines */
        width: 100%;                    /* optional: make it full width */
        font-family: system-ui, sans-serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;      /* light gray header background */
        text-align: left;               /* header text alignment */
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;         /* subtle border color */
        padding: 8px 12px;              /* breathing room */
    }

    tr:nth-child(even) {
        background-color: #fafafa;      /* zebra striping for readability */
    }

    tr:hover {
        background-color: #f0f8ff;      /* light hover highlight */
    }

    .hl-red {
        background-color: red;
    }

    .hl-green {
        background-color: green;
    }

    .hl-blue {
        background-color: blue;
    }

    .hl-yellow {
        background-color: yellow;
    }

    .hl-red-bg {
        background-color: red;
    }

    .hl-green-bg {
        background-color: green;
    }

    .hl-blue-bg {
        background-color: blue;
    }

    .hl-yellow-bg {
        background-color: yellow;
    }

    .hl-red-fg {
        color: red;
    }

    .hl-green-fg {
        color: green;
    }

    .hl-blue-fg {
        color: blue;
    }

    .hl-yellow-fg {
        color: yellow;
    }

    .hl-grey-fg {
        color: grey;
    }

    .hl-black-fg {
        color: black;
    }

    .comment {
        color: grey;
    }

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px; /* optional: make it a bit thicker */
        text-underline-offset: 2px;     /* optional: move it slightly down */
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;                     /* text */
        background-color: #f6f8fa;          /* bg */
        border: 1px solid #d0d7de;          /* subtle frame */
        border-radius: .375rem;
        padding: .15rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;                /* 14px-ish; avoid bare numbers */
        line-height: 1.4;
    }

    /* Block code container */
    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;       /* match inline bg */
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;                   /* scroll if long */
        tab-size: 4;                      /* adjust as needed */
    }

    /* Code inside pre: remove extra padding/background from inline style */
    pre code {
        display: block;                   /* ensure full-width */
        padding: 0;                       /* pre handles padding */
        background: transparent;          /* avoid double bg */
        border: 0;                        /* avoid double border */
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;                 /* preserve spacing; use pre-wrap to wrap long lines */
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<!-- * * * * * * * * * * * * * * -->


<hr/>
<h1>Project Euler #1 - Sum of Multiples of 3 or 5</h1>
<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>C Solution Walkthrough</h3>
<ol>
    <li><b>Problem Statement</b></li>
    <br/>
    <ul>
        <li>
            <i>
                Find the sum of all the natural numbers below <code>N</code> that are multiples of <code>3</code> or <code>5</code>.
            </i>
        </li>
        <br/>
        <li>For the original problem, <code>N = 1000</code>.</li>
        <br/>
        <li>Example for a smaller <code>N</code>:
            <ul>
                <li>Below <code>10</code>, the multiples of <code>3</code> or <code>5</code> are <code>3, 5, 6, 9</code>.</li>
                <li>Their sum is <code>3 + 5 + 6 + 9 = 23</code>.</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>My C Solution</b></li>
    <br/>
<pre><code class="language-c line-numbers">#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;

#ifndef N
#define N (1000ul)
#endif // N

uint64_t solve(uint64_t n)
{
    uint64_t sum = 0;
    for (uint64_t i = 3; i &lt; n; i++)
    {
        if (i % 3 == 0 || i % 5 == 0)
        {
            sum += i;
        }
    }
    return sum;
}

int main()
{
    fprintf(
            stdout,
            "The sum of all the multiples of 3 or 5 below %lu is: %lu\n",
            N,
            solve( N ));
    return 0;
}
</code></pre>
    <br/>
    <br/>


    <li><b>High-Level Approach</b></li>
    <br/>
    <ul>
        <li>We want all numbers <code>i</code> such that:
            <ul>
                <li><code>0 &lt; i &lt; N</code></li>
                <li>and <code>i</code> is divisible by <code>3</code> or <code>5</code></li>
            </ul>
        </li>
        <br/>
        <li>The algorithm you used is straightforward and readable:</li>
        <ol>
            <li>Start with <code>sum = 0</code>.</li>
            <li>Loop over all integers <code>i</code> from <code>3</code> up to (but not including) <code>N</code>.</li>
            <li>If <code>i</code> is a multiple of <code>3</code> or <code>5</code>, add it to <code>sum</code>.</li>
            <li>At the end, return <code>sum</code>.</li>
        </ol>
        <br/>
        <li>This is an <b>O(N)</b> solution: it checks each integer once.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Header Files and Types</b></li>
    <br/>
<pre><code class="language-c line-numbers">#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;
</code></pre>
    <br/>
    <ul>
        <li><code>&lt;stdint.h&gt;</code> is included so you can use fixed-width integer types like <code>uint64_t</code>.</li>
        <br/>
        <li><code>&lt;stdio.h&gt;</code> is needed for <code>fprintf</code> and <code>stdout</code> in <code>main</code>.</li>
        <br/>
        <li>Using <code>uint64_t</code> for the sum is a defensive choice:
            <ul>
                <li>It's a 64-bit unsigned integer — very large range before overflow.</li>
                <li>Even if you increased <code>N</code> (for other experiments), your sum is unlikely to overflow quickly.</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>The N macro (configurable limit)</b></li>
    <br/>
<pre><code class="language-c line-numbers">#ifndef N
#define N (1000ul)
#endif // N
</code></pre>
    <br/>
    <ul>
        <li>This allows <code>N</code> to be defined at compile-time (for example via <code>-DN=2000</code>), while still having a default.</li>
        <br/>
        <li>If <code>N</code> is not already defined, it defaults to <code>1000ul</code>:
            <ul>
                <li><code>1000ul</code> → <code>unsigned long</code> literal.</li>
                <li>Good match for the <code>%lu</code> format specifier in <code>fprintf</code>.</li>
            </ul>
        </li>
        <br/>
        <li>So you can compile like:</li>
    </ul>
<pre><code class="language-bash line-numbers">gcc -DN=5000 euler1.c -o euler1
./euler1
</code></pre>
    <br/>
    <ul>
        <li>Now the program will compute the sum below <code>5000</code> instead of <code>1000</code>, without changing the source code.</li>
    </ul>
    <br/>
    <br/>


    <li><b>The <code>solve</code> Function</b></li>
    <br/>
<pre><code class="language-c line-numbers">uint64_t solve(uint64_t n)
{
    uint64_t sum = 0;
    for (uint64_t i = 3; i &lt; n; i++)
    {
        if (i % 3 == 0 || i % 5 == 0)
        {
            sum += i;
        }
    }
    return sum;
}
</code></pre>
    <br/>
    <ul>
        <li><code>uint64_t solve(uint64_t n)</code>:
            <ul>
                <li>The function takes a single parameter <code>n</code> — the exclusive upper bound.</li>
                <li>It returns the total sum as a 64-bit unsigned integer.</li>
            </ul>
        </li>
        <br/>
        <li><code>uint64_t sum = 0;</code>:
            <ul>
                <li>Initializes the running total.</li>
            </ul>
        </li>
        <br/>
        <li>The <code>for</code> loop:
<pre><code class="language-c line-numbers">for (uint64_t i = 3; i &lt; n; i++)
</code></pre>
            <ul>
                <li>Starts <code>i</code> at <code>3</code> because <code>1</code> and <code>2</code> are not multiples of <code>3</code> or <code>5</code> (you could also start from <code>1</code>, but this is a tiny micro-optimization).</li>
                <li>Runs while <code>i &lt; n</code>, so <code>n</code> itself is not included — which exactly matches "below <code>n</code>".</li>
            </ul>
        </li>
        <br/>
        <li>The condition:
<pre><code class="language-c line-numbers">if (i % 3 == 0 || i % 5 == 0)
</code></pre>
            <ul>
                <li><code>i % 3 == 0</code> → <code>i</code> is divisible by 3.</li>
                <li><code>i % 5 == 0</code> → <code>i</code> is divisible by 5.</li>
                <li>The logical OR <code>||</code> means if either is true, the number counts.</li>
                <li>This automatically handles numbers like <code>15</code> which are multiples of both 3 and 5 — they are still added only once because the condition is just a yes/no test.</li>
            </ul>
        </li>
        <br/>
        <li>Accumulating into <code>sum</code>:
<pre><code class="language-c line-numbers">sum += i;
</code></pre>
            <ul>
                <li>Each qualifying <code>i</code> is added to the running total.</li>
            </ul>
        </li>
        <br/>
        <li>Finally:
<pre><code class="language-c line-numbers">return sum;
</code></pre>
            <ul>
                <li>After finishing the loop, the function returns the total sum of all such multiples.</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>The <code>main</code> Function</b></li>
    <br/>
<pre><code class="language-c line-numbers">int main()
{
    fprintf(
            stdout,
            "The sum of all the multiples of 3 or 5 below %lu is: %lu\n",
            N,
            solve( N ));
    return 0;
}
</code></pre>
    <br/>
    <ul>
        <li><code>solve(N)</code> calls your function with the compile-time constant <code>N</code>.</li>
        <br/>
        <li><code>fprintf(stdout, ...)</code> prints the result to standard output:
            <ul>
                <li><code>%lu</code> is used twice for printing <code>unsigned long</code> values (for <code>N</code> and the result).</li>
                <li>This matches <code>1000ul</code> as the default <code>N</code>.</li>
            </ul>
        </li>
        <br/>
        <li>The output is a friendly sentence:
<pre><code class="language-text">
The sum of all the multiples of 3 or 5 below 1000 is: 233168
</code></pre>
        </li>
        <br/>
        <li><code>return 0;</code> indicates successful program termination.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Complexity and Performance</b></li>
    <br/>
    <ul>
        <li>The loop runs once for every integer <code>i</code> from <code>3</code> to <code>n-1</code>.</li>
        <br/>
        <li>Time complexity: <b>O(n)</b>.</li>
        <br/>
        <li>Space complexity: <b>O(1)</b> — only a few integer variables.</li>
        <br/>
        <li>For <code>n = 1000</code>, this is extremely fast. Even for quite large <code>n</code>, this approach is fine in C.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Haskell Solution Walkthrough</h3>
<ol>
    <li><b>Problem Statement</b></li>
    <br/>
    <ul>
        <li>Same as before.</li>
    </ul>
    <br/>
    <br/>


    <li><b>The Full Haskell Solution</b></li>
<pre><code class="language-haskell line-numbers">main :: IO ()
main = print $ sum [x | x &lt;- [1 .. 999], x `mod` 3 == 0 || x `mod` 5 == 0]
</code></pre>
    <br/>
    <ul>
        <li>This is a compact but fully functional Haskell program — no helper functions required.</li>
        <li>We'll now break it down line by line to understand every part.</li>
    </ul>
    <br/>
    <br/>


    <li><b>The Type Signature</b></li>
<pre><code class="language-haskell line-numbers">main :: IO ()
</code></pre>
    <br/>
    <ul>
        <li>In Haskell, every program must have a <code>main</code> function of type <code>IO ()</code>.</li>
        <br/>
        <li>This means it performs side effects (printing to the console) but doesn't return a value in the pure sense — the empty parentheses <code>()</code> mean "no meaningful value."</li>
        <br/>
        <li>All computation inside <code>main</code> must therefore be expressed as an <b>IO action</b>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>The Body of <code>main</code></b></li>
<pre><code class="language-haskell line-numbers">main = print $ sum [x | x &lt;- [1 .. 999], x `mod` 3 == 0 || x `mod` 5 == 0]
</code></pre>
    <br/>
    <ul>
        <li>This line combines three main concepts in idiomatic Haskell:
            <ol>
                <li><b>List comprehension</b> — to build the list of all numbers divisible by 3 or 5.</li>
                <li><b>sum</b> — a built-in higher-order function that adds all elements in a list.</li>
                <li><b>print</b> — an I/O action that displays the result.</li>
            </ol>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>List Comprehension</b></li>
<pre><code class="language-haskell line-numbers">[x | x &lt;- [1 .. 999], x `mod` 3 == 0 || x `mod` 5 == 0]
</code></pre>
    <br/>
    <ul>
        <li>This is Haskell's <b>list comprehension</b> syntax, inspired by mathematical set notation.</li>
        <br/>
        <li>It can be read as:
            <blockquote>
                "The list of all <code>x</code> taken from <code>[1..999]</code>, such that <code>x</code> is divisible by 3 or 5."
            </blockquote>
        </li>
        <br/>
        <li>Breaking it down:
            <ul>
                <li><code>[1 .. 999]</code> → Generates all integers from 1 to 999 (inclusive).</li>
                <li><code>x &lt;- [1 .. 999]</code> → Means "take each <code>x</code> from that list."</li>
                <li><code>x `mod` 3 == 0 || x `mod` 5 == 0</code> → The filtering condition.</li>
            </ul>
        </li>
        <br/>
        <li>So only numbers satisfying the condition remain in the resulting list.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using <code>sum</code></b></li>
<pre><code class="language-haskell line-numbers">sum [x | x &lt;- [1 .. 999], x `mod` 3 == 0 || x `mod` 5 == 0]
</code></pre>
    <br/>
    <ul>
        <li><code>sum</code> is a built-in Haskell function that adds up all elements in a list of numbers.</li>
        <br/>
        <li>Type signature (simplified):
<pre><code class="language-haskell">sum :: (Num a) =&gt; [a] -&gt; a
</code></pre>
        </li>
        <li>It takes a list of numbers and returns their total.</li>
        <br/>
        <li>Here, <code>[x | ...]</code> produces a list like <code>[3,5,6,9,10,12,...,999]</code>, and <code>sum</code> adds them together.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Printing the Result</b></li>
<pre><code class="language-haskell line-numbers">print $ sum [...]
</code></pre>
    <br/>
    <ul>
        <li><code>print</code> is a standard I/O function in Haskell that converts a value to a string and writes it to standard output.</li>
        <br/>
        <li>Type signature:
<pre><code class="language-haskell">print :: Show a =&gt; a -&gt; IO ()
</code></pre>
        </li>
        <br/>
        <li>The <code>$</code> operator is just syntactic sugar for parentheses:
            <ul>
                <li><code>print $ sum [ ... ]</code> = <code>print (sum [ ... ])</code></li>
            </ul>
        </li>
        <br/>
        <li>The whole expression produces an <code>IO ()</code> action — suitable for <code>main</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Putting It All Together</b></li>
    <br/>
    <ul>
        <li>The evaluation steps conceptually look like this:</li>
    </ul>
<pre><code class="language-haskell line-numbers">-- Step 1: Generate the list
[x | x &lt;- [1..999], x `mod` 3 == 0 || x `mod` 5 == 0]
-- =&gt; [3,5,6,9,10,12,15,18,20,...,999]

-- Step 2: Sum the list
sum [3,5,6,9,10,12,15,...,999]
-- =&gt; 233168

-- Step 3: Print the result
print 233168
</code></pre>
    <br/>
    <ul>
        <li>Haskell lazily generates and sums the list; memory use stays small because it doesn't keep the entire list in memory at once — elements are processed as needed.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Performance Consideration</b></li>
    <br/>
    <ul>
        <li>This is an <b>O(n)</b> approach: it checks every number up to 999 once.</li>
        <br/>
        <li>For such a small range, this is trivial and effectively instantaneous.</li>
        <br/>
        <li>Like the C version, you could also use a mathematical shortcut with arithmetic series, but Haskell's concise syntax makes even the direct version perfectly fine.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Alternative: Using Higher-Order Functions</b></li>
<pre><code class="language-haskell line-numbers">main :: IO ()
main = print . sum . filter f $ [1..999]
  where f x = x `mod` 3 == 0 || x `mod` 5 == 0
</code></pre>
    <br/>
    <ul>
        <li>This version uses <code>filter</code> and function composition (<code>.</code>) instead of list comprehension.</li>
        <li>Both are equivalent; the choice is stylistic.</li>
        <li>Haskell programmers often prefer whichever feels more readable in context.</li>
    </ul>
    <br/>
</ol>
<br/>

<!-- * * * * * * * * * * * * * * -->


<hr/>
<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
